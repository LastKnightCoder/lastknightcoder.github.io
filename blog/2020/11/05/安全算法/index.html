<!doctype html>
<html lang="zh-CN" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">安全算法 | 人生天地间，忽如远行客</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://lastknightcoder.github.io//blog/2020/11/05/安全算法"><meta data-rh="true" name="docusaurus_locale" content="zh-CN"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="zh-CN"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="安全算法 | 人生天地间，忽如远行客"><meta data-rh="true" name="description" content="我们在使用互联网交换数据时，数据需要经过各种各样的网络设备才能到达通信双方，如果数据在传输的过程中经过某些恶意用户的设备，就有可能导致信息被窃取。所以如果想安全的使用互联网，了解必须的安全技术是不可或缺的。"><meta data-rh="true" property="og:description" content="我们在使用互联网交换数据时，数据需要经过各种各样的网络设备才能到达通信双方，如果数据在传输的过程中经过某些恶意用户的设备，就有可能导致信息被窃取。所以如果想安全的使用互联网，了解必须的安全技术是不可或缺的。"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2020-11-05T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/LastKnightCoder"><meta data-rh="true" property="article:tag" content="安全,数字签名,数字证书"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://lastknightcoder.github.io//blog/2020/11/05/安全算法"><link data-rh="true" rel="alternate" href="https://lastknightcoder.github.io//blog/2020/11/05/安全算法" hreflang="zh-CN"><link data-rh="true" rel="alternate" href="https://lastknightcoder.github.io//blog/2020/11/05/安全算法" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="人生天地间，忽如远行客 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="人生天地间，忽如远行客 Atom Feed">
<link rel="alternate" type="application/json" href="/blog/feed.json" title="人生天地间，忽如远行客 JSON Feed">




<link rel="stylesheet" href="/katex/katex.min.css"><link rel="stylesheet" href="/assets/css/styles.5f9e2493.css">
<link rel="preload" href="/assets/js/runtime~main.a19375c5.js" as="script">
<link rel="preload" href="/assets/js/main.ec0e423f.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="" class="themedImage_ToTc themedImage--light_HNdA" height="60" width="60"><img src="/img/logo.svg" alt="" class="themedImage_ToTc themedImage--dark_i4oU" height="60" width="60"></div><b class="navbar__title text--truncate">Coder</b></a></div><div class="navbar__items navbar__items--right"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Slides</a><ul class="dropdown__menu"><li><a href="https://lastknightcoder.github.io/slides-flex/" target="_blank" rel="noopener noreferrer" class="dropdown__link">Flex布局<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://lastknightcoder.github.io/slides-grid/" target="_blank" rel="noopener noreferrer" class="dropdown__link">Grid布局<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://lastknightcoder.github.io/slides-svg/" target="_blank" rel="noopener noreferrer" class="dropdown__link">SVG<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><hr style="margin: 0.3rem 0;"></li><li><a href="https://lastknightcoder.github.io/slides-dissertation/" target="_blank" rel="noopener noreferrer" class="dropdown__link">毕业论文<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><a href="https://github.com/LastKnightCoder/lastknightcoder.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">所有的博客</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/mobile-text-middle">移动端文字垂直居中方案</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/MutationObserver">MutationObserver</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/IntersectionObserver">IntersectionObserver</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/selection-and-range">Selection与Range</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/css-animation-timer">使用CSS动画取代定时器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/encodeURI与encodeURIComponent">encodeURI与encodeURIComponent</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/06/12/Rust生命周期">Rust生命周期</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/05/17/部署YOLOv5训练">部署YOLOv5训练</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/10/行内样式使用 important">行内样式使用 important</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/03/11/HTTP2之旅">HTTP2之旅</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/01/12/从手抄笔记到个人博客">从手抄笔记到个人博客</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2021/12/10/Canvas绘图模糊">Canvas绘图模糊</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2021/11/25/我是如何成为一名程序员的">我是如何成为一名程序员的</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2021/11/22/使用Notion作为视频托管">使用Notion作为视频托管</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2021/11/12/远程访问 jupyter">远程访问 jupyter</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/柯里化">柯里化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2021/05/31/使用 Github Actions 部署 VuePress 博客">使用 Github Actions 部署 VuePress 博客</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/控制对象的访问">控制对象的访问</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/EventEmitter">EventEmitter</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2021/03/06/Stream">Stream</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/Buffer">Buffer</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/2020/11/05/安全算法">安全算法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2020/08/30/小球会停下来吗">小球会停下来吗</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/手写Promise">手写Promise</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2020/05/30/TypeScript入门指南">TypeScript入门指南</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/正则表达式">正则表达式</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/防抖与节流">防抖与节流</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/Ajax跨域">Ajax跨域</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">安全算法</h1><div class="container_mt6G margin-vert--md"><time datetime="2020-11-05T00:00:00.000Z" itemprop="datePublished">2020年11月5日</time> · <!-- -->阅读需 21 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/LastKnightCoder" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://cdn.staticaly.com/gh/LastKnightCoder/ImgHosting3@master/wallhaven-8opwwy.3cbn7rc981c0.webp" alt="熊滔"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/LastKnightCoder" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">熊滔</span></a></div><small class="avatar__subtitle" itemprop="description">前端工程师 @ 阿里巴巴</small></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><p>我们在使用互联网交换数据时，数据需要经过各种各样的网络设备才能到达通信双方，如果数据在传输的过程中经过某些恶意用户的设备，就有可能导致信息被窃取。所以如果想安全的使用互联网，了解必须的安全技术是不可或缺的。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="安全问题">安全问题<a class="hash-link" href="#安全问题" title="标题的直接链接">​</a></h2><p>我们首先了解一下在通信的过程中会遇到什么样的安全问题。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="窃听">窃听<a class="hash-link" href="#窃听" title="标题的直接链接">​</a></h3><video controls="" src="https://video-obsidian.oss-cn-beijing.aliyuncs.com/Safe01.mp4"></video><p>A 向 B 发送的信息可能会在传输的过程中被 X 偷看，这就是窃听。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="假冒">假冒<a class="hash-link" href="#假冒" title="标题的直接链接">​</a></h3><img loading="lazy" src="https://cdn.staticaly.com/gh/LastKnightCoder/ImgHosting3@master/image.7fch8qj4mxc0.webp" class="img_ev3q"><p>A 以为给 B 发送了消息，但是 B 有可能是 X 冒充的；同样 B 以为收到了 A 的消息，但是 A 也有可能是 X 冒充的，这种问题叫做假冒。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="篡改">篡改<a class="hash-link" href="#篡改" title="标题的直接链接">​</a></h3><video controls="" src="https://video-obsidian.oss-cn-beijing.aliyuncs.com/Safe02.mp4"></video><p>B 确实收到了 A 发送的信息，但是内容已经被 X 给改变了，这种行为叫做篡改。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="事后否认">事后否认<a class="hash-link" href="#事后否认" title="标题的直接链接">​</a></h3><video controls="" src="https://video-obsidian.oss-cn-beijing.aliyuncs.com/Safe03.mp4"></video><p>B 从 A 那里收到了消息，但是 A 在事后宣称消息不是它发的，这会导致互联网上的商业交易或合同无法成立，这种行为叫做事后否认。</p><p>在这篇文章中就着重解决这四类问题，对于窃听，我们对消息进行加密技术；对于假冒，我们使用消息认证码或数字签名；对于篡改，我们同样可以使用消息认证码或数字签名；对于事后否认，我们可以使用数字签名。</p><table><thead><tr><th>问题</th><th>解决办法</th></tr></thead><tbody><tr><td>窃听</td><td>加密</td></tr><tr><td>假冒</td><td>消息认证码或数字签名</td></tr><tr><td>篡改</td><td>消息认证码或数字签名</td></tr><tr><td>事后否认</td><td>数字签名</td></tr></tbody></table><p>数字签名存在无法确认公开密钥制作者的问题，我们可以使用数字证书来解决，具体的过程我们在后面分析。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="对称加密">对称加密<a class="hash-link" href="#对称加密" title="标题的直接链接">​</a></h2><p>如果我们在互联网上直接将消息发送过去的话，有可能会被窃听，所以我们需要将消息变为密文，然后发送出去，将消息变为密文的过程叫做加密，同样在接收方需要将密文变为明文(消息)，这个过程叫做解密。</p><p>在加密和解密的过程中需要用到密钥，所谓的密钥可以类比于钥匙，钥匙的作用就是加锁与开锁，而密钥的作用是加密与解密。根据加密和解密是否使用的是相同的密钥，可以分为对称加密与非对称加密：</p><ul><li>对称加密：加密和解密的密钥是同一个密钥</li><li>非对称加密：加密和解密的密钥不相同</li></ul><p>在本小节中就介绍对称加密，以及对称加密存在什么问题。</p><p>对称加密的过如下：</p><img loading="lazy" src="https://cdn.staticaly.com/gh/LastKnightCoder/ImgHosting3@master/20201031092108.utibeyvdfgg.gif" class="img_ev3q"><ol><li>A 将密钥 key 发送给 B</li><li>A 使用密钥 key 对消息 aaa 加密，得到密文 xyz</li><li>B 接到密文 xyz，使用密钥 key 对密文解密得到 aaa</li></ol><p>这时如果窃听者来窃听的话，因为窃听者没有密钥，所以无法得知明文是什么。</p><p>但是上述的加密有一个问题，如果密钥 key 在 A 发送给 B 的时候被窃听了</p><img loading="lazy" src="https://cdn.staticaly.com/gh/LastKnightCoder/ImgHosting3@master/image.6fp3kh5cn140.webp" class="img_ev3q"><p>这时窃听者就知道密钥，以此将密文解密，从而窃听消息。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="非对称加密">非对称加密<a class="hash-link" href="#非对称加密" title="标题的直接链接">​</a></h2><p>非对称加密指的是加密的密钥和解密的密钥不是同一个密钥，我们把加密密钥称为公开密钥，因为它是可以公开的，任何人都可以访问到，我们称解密密钥为私有密钥。</p><p>当 A 给 B 发送消息时，在此之前，B 会生成公开密钥和私有密钥，然后 B 将公开密钥发送给 A，接着 A 使用该公开密钥加密消息，并将消息发送给 B，当 B 接收到消息之后，使用私有密钥对消息解密</p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/LastKnightCoder/image-for-2022@master/20201030185737762022-10-23-19-40-08.gif" class="img_ev3q"><p>即使窃听者窃听到了密文以及公开密钥，但是它没有私有密钥，所以它不能解密出消息。</p><p>但是这种方法并不是完美的，假设在 B 向 A 发送公开密钥时，窃听者将 B 公开密钥修改为了自己的公开密钥发送给 A</p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/LastKnightCoder/image-for-2022@master/202010310922452022-10-23-19-41-36.gif" class="img_ev3q"><p>因为公开密钥并不能指明来源是谁，当 A 接收到密钥时误以为是 B 的公开密钥，这样当 A 向 B 发送消息时，其实使用的是窃听者的公开密钥来加密消息，这时窃听者通过私钥解密，从而窃听到消息</p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/LastKnightCoder/image-for-2022@master/202010310923102022-10-23-19-42-37.gif" class="img_ev3q"><p>并且再次使用 B 的公开密钥加密消息，将消息发送给 B，对于 A 和 B 来说，它们完全没有意识到自己被窃听了</p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/LastKnightCoder/image-for-2022@master/202010310923262022-10-23-19-43-38.gif" class="img_ev3q"><p>这种通过中途替换公开密钥来窃听数据的攻击方法叫做<strong>中间人攻击</strong>。</p><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</div><div class="admonitionContent_S0QG"><p>非对称加密可靠性会出现问题就是因为 A 无法判断接收到的密钥是否来自于 B，想要解决这个问题，就要用到后面讲到的数字证书。</p></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="混合加密">混合加密<a class="hash-link" href="#混合加密" title="标题的直接链接">​</a></h2><p>使用非对称加密虽然比对称加密安全，但是非对称加密方法加密和解密所需的资源以及时间比对称加密方法所需的资源和时间代价高很多，那么就有人提出一种加密方式，同时使用对称加密和非对称加密这种混合加密的方式，既能得到非对称加密的安全性，又能得到对称加密的快速性。</p><p>首先我们上面谈到对称加密时有讲到对称加密的缺点，那就是需要将加密的密钥在互联网上传输，而密钥有可能会被窃听者窃取。</p><p>如果我们使用非对称加密的方法来加密对称加密的密钥，这样对称加密的密钥就不会被窃听者窃取，因为窃听者没有私钥，然后在下面的通信过程中使用对称加密的密钥加密消息，因为我们只使用了非对称加密加密了对称加密所使用的密钥，而消息的加密都是通过对称加密的密钥加密的，所以不会存在速度慢的问题，这样既保证了安全性，又兼顾了加解密所需的资源和时间。</p><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</div><div class="admonitionContent_S0QG"><p>目前在网页中使用的 HTTPS 协议使用的就是混合加密的方式。</p></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="密钥交换算法">密钥交换算法<a class="hash-link" href="#密钥交换算法" title="标题的直接链接">​</a></h2><p>Diffie-Hellman 密钥交换可以解决使用对称加密方法进行通信时密钥被窃听的问题。在讲解该算法的消息过程之前，我们先了解一下该算法的概念。</p><p>该算法它可以合成两个密钥</p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/LastKnightCoder/image-for-2022@master/202010310946222022-10-23-19-44-37.png" class="img_ev3q"><p>并且合成的密钥有三个特点</p><ol><li><p>已知其中一个密钥，无法根据合成的密钥推断出另一个密钥</p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/LastKnightCoder/image-for-2022@master/202010311009162022-10-23-19-46-02.png" class="img_ev3q"></li><li><p>合成的密钥可以继续与其他的密钥进行合成</p></li><li><p>密钥合成的结果与合成的顺序无关</p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/LastKnightCoder/image-for-2022@master/202010311017202022-10-23-19-47-41.png" class="img_ev3q"></li></ol><p>现在我们就使用这种方法在 A 和 B 之间传递密钥，首先由 A 生成密钥 P，然后将该密钥发送给 B，在这个过程中有可能被窃听者 X 窃取到密钥，所以这时的密钥不能被用来加密消息</p><img loading="lazy" src="https://gitee.com/lastknightcoder/blogimage/raw/master/20201031102913.gif" class="img_ev3q"><p>接着 A 和 B 各自生成自己的私钥 SA 和 SB，并使用上述的合成方法与密钥 P 进行合成，然后发送给对方，双方接收到对方合成的密钥后，再将密钥与自己的私钥合成，如下</p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/LastKnightCoder/image-for-2022@master/202010311029132022-10-23-19-48-25.gif" class="img_ev3q"><p>最后，A 得到密钥 <code>P|SB|SA</code>，而 B 得到密钥 <code>P|SA|SB</code>，根据算法特点 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">3</span></span></span></span></span>，合成的密钥与合成的顺序无关，所以二者的密钥是相同的，所以接下来 A 和 B 可以用该密钥来加密和解密消息。</p><p>那窃听者有可能窃听该密钥吗? 通过上面的动图我们知道窃听者掌握的信息有密钥 P，以及两个合成密钥 <code>P|SA</code> 和 <code>P|SB</code>，根据算法特点 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span></span>，窃听者是无法推断 SA 和 SB 的，所以窃听者就不能合成出密钥 <code>P|SA|SB</code>。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="消息认证码">消息认证码<a class="hash-link" href="#消息认证码" title="标题的直接链接">​</a></h2><p>消息认证码可以检测篡改，例如下面的场景</p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/LastKnightCoder/image-for-2022@master/202011041404052022-10-23-19-49-12.gif" class="img_ev3q"><p>A 向 B 发送一个消息，在中途消息被恶意用户修改了，但是 B 并没有意识到消息已经被修改了，以为接收到的消息就是 A 发送的消息。消息认证码可以预防这种情况发生。</p><p>下面看一下使用消息认证码发消息的流程：</p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/LastKnightCoder/image-for-2022@master/20201104144958942022-10-23-19-49-48.gif" class="img_ev3q"><ol><li>A 生成了一个生成消息认证码的密钥，并以安全的方式将密钥发送给了 B</li><li>A 根据消息内容(已加密)，使用密钥生成一个值，这个生成的值就是消息认证码，简称 MAC(Message Authentication Code)</li><li>A 将消息和 MAC 发送给 B</li><li>B 根据接收到的消息，使用 A 之前发送的密钥生成一个值，如果这个值与 A 发送过来的 MAC 相同，则可以认为消息是没有被篡改过的</li><li>接下来只需要对密文解密即可</li></ol><p>如果在中途 X 对 A 发送的消息进行了篡改，那么 B 收到的密文和 A 发送的密文不同，那么 B 生成的消息认证码和 A 发送的消息认证码就不相同，这个时候 B 就知道消息被篡改过了，这时可以要求 A 重新发送消息。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="数字签名">数字签名<a class="hash-link" href="#数字签名" title="标题的直接链接">​</a></h2><p>消息认证码虽然解决了篡改的问题，但是因为他们使用的是相同的密钥加密和解密，所以 B 也可以生成消息认证码，所以事后 A 可以否认消息并不是他发的，因为不仅仅是他可以生成消息认证码(事情又不是我一个人可以干，你凭什么说是我干的)。</p><p>使用数字签名不仅可以解决篡改问题，还可以解决事后否认问题。假设 A 给 B 发送消息，我们首先看一下流程：</p><ol><li>A 在发送前给消息加上数字签名，数字签名只能由 A 生成</li><li>B 收到 A 的消息，验证数字签名的正确性，但是无法生成数字签名</li></ol><p>因为数字签名只能由 A 生成，所以 A 无法在事后否认(这件事情就你能干，不是你干的是谁干的)。</p><p>我们看一下使用数字签名通信的详细过程：</p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/LastKnightCoder/image-for-2022@master/202011042043302022-10-23-19-50-39.gif" class="img_ev3q"><ol><li>A 生成一对公钥和私钥，公钥是每个人都知道的，私钥是 A 独有的，A 使用私钥对消息(已加密后的消息)加密，得到数字签名</li><li>A 将消息以及数字签名发送给 B</li><li>B 使用 A 的公钥对消息解密，得到一个数字签名，验证该数字签名与 A 发送数字签名是否相同</li><li>数字签名确认无误，说明消息没有经过篡改，并且可以确认消息是 A 发的，可以对消息解密得到明文</li></ol><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</div><div class="admonitionContent_S0QG"><p>上述过程有两次加密，第一次加密是对明文进行加密，得到密文防止被窃听，第二次加密是根据密文生成数字签名。对应的也要进行两次解密，第一次解密是为了得到数字签名，从而验证数字签名的正确性，如果数字签名确认无误，那么就需要进行第二次解密，将密文变换为明文，得到真正的消息。</p></div></div><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</div><div class="admonitionContent_S0QG"><p>事实上，使用私钥对全部的消息进行加密比较耗费时间，一般是根据消息生成哈希值，然后对哈希值加密得到数字签名。</p></div></div><p>因为数字签名是使用私钥进行加密的，只有 A 有私钥，所以 A 无法事后否认。</p><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</div><div class="admonitionContent_S0QG"><p>在本小节比较强调数字签名在事后否认方面的作用，但是数字签名可以用来检测消息是否被篡改，因为数字签名的生成与消息的内容是有关的，如果消息被篡改了，那么生成的数字签名就不对，就可以得知消息被篡改了或者不是 A 发送的消息。</p></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="数字证书">数字证书<a class="hash-link" href="#数字证书" title="标题的直接链接">​</a></h2><p>因为数字签名没有解决公开密钥制作者的问题，所以如果 X 假冒 A 给 B 发送消息，此时 X 会生成一对公钥和私钥，并且将公钥发送给 B，因为公钥中没有携带发送者的信息，B 就会使用该公钥来验证数字签名，对于 B 来说他以为自己在和 A 通信，实际上在与 A 通信。</p><p>解决这个问题需要使用数字证书，假设 A 给 B 发送消息，通信过程如下：</p><ol><li><p>A 将包含公开密钥以及自己的相关信息(如邮箱)的个人资料发送给认证中心</p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/LastKnightCoder/image-for-2022@master/202011042203512022-10-23-19-52-38.gif" class="img_ev3q"></li><li><p>认证中心根据 A 的资料使用自己的私钥生成一个数字签名，并且将数字签名以及资料放进同一个文件中</p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/LastKnightCoder/image-for-2022@master/202011042209202022-10-23-19-53-44.gif" class="img_ev3q"></li><li><p>认证中心将该文件发送给 A，该文件就是 A 数字证书</p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/LastKnightCoder/image-for-2022@master/202011042211062022-10-23-19-54-38.gif" class="img_ev3q"></li><li><p>A 将包含公开密钥的数字证书发送给 B，B 收到证书后，首先对 A 的身份进行确认(如邮箱是否是 A 的邮箱)，接着获取认证中心的公开密钥，使用认证中心的公开密钥对数字签名进行确认，判断是否是认证中心给出的签名</p></li><li><p>如果确认 A 的信息无误，以及签名是认证中心的签名，那么就从证书中取出 A 的公开密钥</p></li></ol><p>如果这时 X 假冒 A 给 B 发送它的公开密钥，这时 B 没有必要信任以非证书的形式发送的公开密钥；这时 X 为了假冒 A 在认证中心登记自己的公开密钥，但是 X 无法使用 A 的信息(如邮箱)，因此无法获得 A 的证书。</p><p><strong>通过数字证书，消息的接收者可以确认公开密钥的制作者。</strong></p><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</div><div class="admonitionContent_S0QG"><p>但是目前还有一个疑问，B 从认证中心得到的公开密钥真的来自于认证中心吗? 如果认证中心也是假冒的呢?</p><p>实际上，认证中心的公开密钥也是以数字证书的形式交付的，会有更高级别的认证中心对这个认证中心署名。</p><p>假设存在一个被社会广泛认可的认证中心 A，此时出现了一家新公司 B 想开展认证中心业务，但是 B 没有得到社会的认可，于是 B 向 A 申请发行数字证书，A 会对 B 是否能开展认证业务进行检测，如果通过了检测，A 就会向 B 发行证书，公司 B 就可以向社会表示自己获得了公司 A 的信任。</p><p>最顶端的认证中心被称为根认证中心，其自身的正当性由自己证明。如果根认证中心不被信任，整个过程就无法运转，所以根认证中心一般是大型企业或者与政府有关联且已经获得了社会信赖的组织。</p></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="参考资料">参考资料<a class="hash-link" href="#参考资料" title="标题的直接链接">​</a></h2><ul><li>《我的第一本算法书》</li></ul></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/安全">安全</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/数字签名">数字签名</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/数字证书">数字证书</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/LastKnightCoder/lastknightcoder/tree/master/blog/2020-11-05-安全算法.mdx" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="博文分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/Buffer"><div class="pagination-nav__sublabel">较新一篇</div><div class="pagination-nav__label">Buffer</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/2020/08/30/小球会停下来吗"><div class="pagination-nav__sublabel">较旧一篇</div><div class="pagination-nav__label">小球会停下来吗</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#安全问题" class="table-of-contents__link toc-highlight">安全问题</a><ul><li><a href="#窃听" class="table-of-contents__link toc-highlight">窃听</a></li><li><a href="#假冒" class="table-of-contents__link toc-highlight">假冒</a></li><li><a href="#篡改" class="table-of-contents__link toc-highlight">篡改</a></li><li><a href="#事后否认" class="table-of-contents__link toc-highlight">事后否认</a></li></ul></li><li><a href="#对称加密" class="table-of-contents__link toc-highlight">对称加密</a></li><li><a href="#非对称加密" class="table-of-contents__link toc-highlight">非对称加密</a></li><li><a href="#混合加密" class="table-of-contents__link toc-highlight">混合加密</a></li><li><a href="#密钥交换算法" class="table-of-contents__link toc-highlight">密钥交换算法</a></li><li><a href="#消息认证码" class="table-of-contents__link toc-highlight">消息认证码</a></li><li><a href="#数字签名" class="table-of-contents__link toc-highlight">数字签名</a></li><li><a href="#数字证书" class="table-of-contents__link toc-highlight">数字证书</a></li><li><a href="#参考资料" class="table-of-contents__link toc-highlight">参考资料</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"></ul></div><div class="col footer__col"><div class="footer__title">Github</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/LastKnightCoder" target="_blank" rel="noopener noreferrer" class="footer__link-item">Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Slides</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://lastknightcoder.github.io/slides-flex/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Flex布局<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://lastknightcoder.github.io/slides-grid/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Grid布局<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://lastknightcoder.github.io/slides-svg/" target="_blank" rel="noopener noreferrer" class="footer__link-item">SVG<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://lastknightcoder.github.io/slides-dissertation/" target="_blank" rel="noopener noreferrer" class="footer__link-item">毕业论文<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.a19375c5.js"></script>
<script src="/assets/js/main.ec0e423f.js"></script>
</body>
</html>